% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/create_structural_metadata.R
\name{create_structural_metadata}
\alias{create_structural_metadata}
\title{Create Structural Metadata from a dataframe}
\usage{
create_structural_metadata(
  data,
  primary_key = "",
  foreign_key = "",
  additional_elements = tibble::tibble()
)
}
\arguments{
\item{data}{Any named object. Expects a table but will work
superficially with lists or named vectors.}

\item{primary_key}{Character. name of field that serves as a primary key}

\item{foreign_key}{Character. Field or fields that are foreign keys}

\item{additional_elements}{Empty tibble with structural metadata elements and
their types.}
}
\value{
dataframe with standard metadata requirements
}
\description{
This is the metadata that describes the data themselves. This metadata can be
generated then joined to pre-existing metadata via field names.
}
\details{
The metadata table produced has the following elements
\itemize{
\item \code{name} = The name of the field. This is taken as is from \code{data}.
\item \code{description} = Description of that field. May be provided by controlled vocabulary
\item \code{units} = Units of measure for that field. May or may not apply
\item \code{term_uri} = Universal Resource Identifier for a term from a controlled vocabulary or schema
\item \code{comments} = Free text providing additional details about the field
\item \code{primary_key} = \code{TRUE} or \code{FALSE}, Uniquely identifies each record in the data
\item \code{foreign_key} = \code{TRUE} or \code{FALSE}, Allows for linkages between data sets. Uniquely identifies
records in a different data set
}
}
\examples{
\dontrun{
df <- data.frame(a = 1:10, b = letters[1:10])
df_metadata  <- ohcleandat::create_structural_metadata(df)
write.csv(df_metadata,"df_metadata.csv")


Additional elements can be added via a tibble
additional_elements <- tibble::tibble(table_name = NA_character_,
created_by = NA_character_,
updated = NA
)
df_metadata  <- ohcleandat::create_structural_metadata(df,
    additional_elements = additional_elements)

# lets pretend we are using a dataset which already has
## in airtable, you can add field descriptions directly
## in the base. We want those exported and properly formatted
## in our ohcleandat workflow

 base <- "appMyBaseID"
 table_name <- "My Table"

 airtable_metadata  <- airtabler::air_generate_metadata_from_api(base = base,
    field_names_to_snake_case = FALSE ) |>
    dplyr::filter(table_name == {table_name}) |>
    dplyr::select(field_name,field_desc,primary_key)

 airtable_df <- airtabler::fetch_all(base = base, table_name = table_name)

 airtable_df_metadata <- ohcleandat::create_structural_metadata(airtable_df)

 metadata_joined <- dplyr::left_join(airtable_df_metadata,airtable_metadata,
 by = c("name"="field_name"))

 metdata_updated <- metadata_joined |>
 dplyr::mutate(description = field_desc,
               primary_key = primary_key.y,
               ) |>
 dplyr::select(-matches('\\\\.[xy]|field_desc'))

# ODK
# get all choices from ODK form

dotenv::load_dot_env()

ruODK::ru_setup(
  svc = "https://odk.server.org/v1/projects/5/forms/myproject.svc",
  un = Sys.getenv("ODK_USERNAME"),
  pw = Sys.getenv("ODK_PASSWORD"),
  tz = "GMT",
  odkc_version = "1.1.2")


schema <- ruODK::form_schema_ext()

schema$choices_flat <-schema$`choices_english_(en)` |>
  purrr::map_chr(\(x){
    if("labels" \%in\% names(x)){
      paste(x$labels,collapse = ", ")
    } else {
      ""
    }

  })

  data_odk <- ruODK::odata_submission_get()
  data_odk_rect <- ruODK::odata_submission_rectangle(data_odk)
  odk_metadata <- ohcleandat::create_structural_metadata(data_odk_rect)


  odk_metadata_joined  <- dplyr::left_join(odk_metadata,schema_simple,
  by = c("name" = "ruodk_name"))

  odk_metadata_choices <- odk_metadata_joined |>
  mutate(description = choices_flat) |>
  select(-choices_flat)


}

}
